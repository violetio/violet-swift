//
// LoginResponse.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** Login Response */
public struct LoginResponse: Codable, JSONEncodable, Hashable {

    public enum ModelType: String, Codable, CaseIterable {
        case admin = "ADMIN"
        case merchant = "MERCHANT"
        case user = "USER"
        case developer = "DEVELOPER"
    }
    public enum Status: String, Codable, CaseIterable {
        case inactive = "INACTIVE"
        case active = "ACTIVE"
        case disabled = "DISABLED"
    }
    public var id: Int64?
    /** The users first name */
    public var firstName: String
    /** The users last name */
    public var lastName: String
    /** The users unique email address */
    public var email: String
    /** The Id of the Store the User is associated to. */
    public var merchantId: Int?
    /** The allowed values for the user type */
    public var type: ModelType
    /** If a user has verified their emailed address */
    public var verified: Bool? = false
    /** The status of the user */
    public var status: Status?
    /** Date of account creation */
    public var dateCreated: Date?
    /** Date of last account update */
    public var dateLastModified: Date?
    public var roles: [Role]?
    /** Users Access Token. Currently expires after 1440 minutes. */
    public var token: String?
    /** Users Refresh Token. Never expires. */
    public var refreshToken: String?

    public init(id: Int64? = nil, firstName: String, lastName: String, email: String, merchantId: Int? = nil, type: ModelType, verified: Bool? = false, status: Status? = nil, dateCreated: Date? = nil, dateLastModified: Date? = nil, roles: [Role]? = nil, token: String? = nil, refreshToken: String? = nil) {
        self.id = id
        self.firstName = firstName
        self.lastName = lastName
        self.email = email
        self.merchantId = merchantId
        self.type = type
        self.verified = verified
        self.status = status
        self.dateCreated = dateCreated
        self.dateLastModified = dateLastModified
        self.roles = roles
        self.token = token
        self.refreshToken = refreshToken
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case id
        case firstName = "first_name"
        case lastName = "last_name"
        case email
        case merchantId = "merchant_id"
        case type
        case verified
        case status
        case dateCreated = "date_created"
        case dateLastModified = "date_last_modified"
        case roles
        case token
        case refreshToken = "refresh_token"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(id, forKey: .id)
        try container.encode(firstName, forKey: .firstName)
        try container.encode(lastName, forKey: .lastName)
        try container.encode(email, forKey: .email)
        try container.encodeIfPresent(merchantId, forKey: .merchantId)
        try container.encode(type, forKey: .type)
        try container.encodeIfPresent(verified, forKey: .verified)
        try container.encodeIfPresent(status, forKey: .status)
        try container.encodeIfPresent(dateCreated, forKey: .dateCreated)
        try container.encodeIfPresent(dateLastModified, forKey: .dateLastModified)
        try container.encodeIfPresent(roles, forKey: .roles)
        try container.encodeIfPresent(token, forKey: .token)
        try container.encodeIfPresent(refreshToken, forKey: .refreshToken)
    }
}

